/*
* Програма 5. Розділення чотирьохзначного числа на розряди.
*
* Призначення програми: лічильник від 0 до 9999 з кроком 1.
*
* Обладнання:
* - мікроконтролер ATmega168
* - чотирьох цифровий семисегментний дисплей 7seg-mpx4-ca;
*
* 7seg-mpx4-ca дисплей складається із чотирьом семисегментних
* індикаторів. Індикатори відносяться до типу із загальним анодом,
* тобто всі сегменти (світлодіоди) індикатору з'єднані своїми
* анодами з джерелом живлення. Виводи мікроконтролеру приєднуються
* до катодів світлодіодів. Щоб відобразити на індикаторі
* певну цифру повинна увімкнутись певна комбінація світлодіодів,
* а решта світлодіодів повинна бути вимкнена.
* Для того, щоб світлодіод індикатора із загальним анодом
* увімкнувся на його катоді повинен бути потенціал нижчий за
* потенціал аноду. Тому, для увімкнення певного сегменту
* індикатора на відповідному виході мікроконтролеру повинен
* бути встановлений логічний нуль. Для вимкнення сегменту на
* виході повинна бути логічна одиниця.
*
* Робота з даним типом дисплея має свої особливості. В кожен
* момент часу можна виводити цифру тільки на один індикатор
* дисплея. Тому, в кожен момент часу увімкнутий тільки один
* індикатор, а всі інші вимкнуті.
* Якщо послідовно вмикати кожен індикатор дисплея через досить
* малий проміжок часу, який менший за час реакція ока людини,
* то складається відчуття, що всі сегменти дисплею увімкнуті
* одночасно.
* В симуляторі PROTEUS для дисплею 7seg-mpx4-ca цей час < 10 мс.
*
* Дисплей 7seg-mpx4-ca містить два набори виводів:
* - перший містить вісім виводів, позначені "ABCDEFG DP";
* - другий містить чотири виводи, позначені "1234".
* Перший набір виводів керує сегментами конкретного індикатору.
* "ABCDEFG" виводи керують сегментами (світлодіодами)
* індикатору для відображення цифри.
* "DP" вивід керує світлодіодом, який відображає десяткову точку
* в правому нижньому куті індикатору.
* Другий набір виводів слугує вибору конкретного індикатора
* дисплея.
*
* Виводи порту D приєднані до виводів "ABCDEFG DP" дисплею:
* PD0-"A", PD1-"B", ..., PD6-"G", PD7-"DP".
* Виводи PB0-PB3 приєднані до виводів "1234":
* PB0-"1", PB1-"2", PB2-"3", PB3-"4".
*
* Кількість тактів таймеру для створення потрібної затримки
* між перемиканнями індикаторів дисплею:
*
* tdel    = 0,010с.
* fclk_io = 1МГц.
* N       = 8.
* f0      = 1МГц/8           = 125000Гц.
* t0      = 1/125000Гц       = 0,000008с.
* n       = 0,010с/0,000008с = 1250
*
*/

#define F_CPU            1000000UL                     /* Тактова частота процесору. */
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define DIGIT_1          (1<<PB0)                      /* Активується 1-й індикатор. */
#define DIGIT_2          (1<<PB1)                      /* Активується 2-й індикатор. */
#define DIGIT_3          (1<<PB2)                      /* Активується 3-й індикатор. */
#define DIGIT_4          (1<<PB3)                      /* Активується 4-й індикатор. */

#define DELAY_DISPLAY    19                            /* Кількість циклів повтору виведених цифр 
                                                          на дисплей. */
#define DIGIT_COUNT      03                            /* Кількість індикаторів - 1. */

#define CLEAR_TIMER      TCNT1 = 0x00                  /* Очистка регістру поточного значення 
	                                                      лічильника. */
#define TIMER_COUNT      1250                          /* Кількість тактів лічильника для формуввання
                                                          затримки в 10 мс. */

/* Масив комбінацій значень виводів порту D для відображення цифр від 0 до 9.
   Індекс масиву відповідає цифрі, яку потрібно вивести на індикатор. */
static const uint8_t number_code[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
/* Масив кодів активації індикаторів. */
static const uint8_t digits[] = {DIGIT_1,DIGIT_2,DIGIT_3,DIGIT_4};
/* Масив для збереження цифр чотирьохзначного числа. */
static uint8_t values[] = {0,0,0,0};

/* Поточне чотирьохзначне число. */
static uint16_t value = 0; 

/* Лічильники циклів. */
static uint8_t i = 0;                                  /* Поточний номер індикатору. */
static uint8_t k = 0;                                  /* Лічильник циклу повтору виведених на 
                                                          дисплей цифр. */

/* Обробник переривань 16-біт таймеру. 
ISR(TIMER1_COMPA_vect)
{
	PORTB = digits[i];                                 /* Активація i-го індикатору. 
	PORTD = number_code[values[i]];                    /* Вивід цифри на i-й індикатор. 

	if(i < DIGIT_COUNT)                                /* Доки поточний номер індикатору не досяг 
	                                                      останнього. 
	{
		i++;                                           /* Переходимо на наступний індикатор. 
	}
	else                                               /* Поточний номер досяг номеру 
	                                                      останнього індикатору. 
	{
		i = 0;                                         /* Переходимо до першого індикатору. 
		if(k < DELAY_DISPLAY)                          /* Доки поточний цикл повтору виведених
		                                                  на дисплей цифр не досяг останнього значення
														  затримки. 
		{
			k++;                                       /* Переходимо до наступного циклу повтору
			                                              виведення цифр на дисплей. 
		}
		else                                           /* Цикл повтору закінчився. 
		{
			k = 0;
		}
	}
}
*/
int main05(void)
{
	/* Ініціалізація вихідних 12 виводів. */
	PORTB = 0x00;
	PORTD = 0x00;
	DDRB = 0x0F;                                       /* Виводи для вибору індикатору. */
	DDRD = 0xFF;                                       /* Виводи для виводу цифр на індикатор. */
	
    /* Налаштування таймеру 1. */
    CLEAR_TIMER;                                                                           
	OCR1A = TIMER_COUNT;                               /* Кількість тактів лічильника. */
	TIMSK1 |= (1<<OCIE1A);                             /* Активація TIMER1_COMPA переривання. */
	sei();                                             /* Глобальна активація переривань. */
	TCCR1A |= 0x00;                                    /* Режим CTC. */
	TCCR1B |= (1<<WGM12)|(1<<CS11);                    /* Вибір внутрішнього джерела тактових 
	                                                      сигналів: fclk_io = F_CPU = 1МГц.
	                                                      Подільник частоти N = 8. 														  
														  Запуск лічильника.*/
	
	uint16_t temp_value = 0;                           /* Тимчасова змінна для зберігання залишків
	                                                      виділення розрядів із чотирьохзначного числа. */
	uint8_t temp_values[] = {0,0,0,0};                 /* Тимчасовий масив для зберігання цифр
		                                                  чотиризначного числа. */
		
	/* Нескінченний цикл розділення чотирьохзначного числа на цифри. */
	while (1)
	{
		_delay_ms(500);                                /* Затримка розділення числа на цифри. */                               
		value++;                                       /* Наступне число. */
		temp_value = value;                            
		temp_values[0] = temp_value/1000;              /* Виділення кількості тисяч в числі. */
		temp_value = temp_value%1000;                  /* Збереження числа без розряду тисяч. */
		temp_values[1] = temp_value/100;               /* Виділення кількості сотень в числі. */
		temp_value = temp_value%100;                   /* Збереження числа без розряду сотень. */
		temp_values[2] = temp_value/10;                /* Виділення кількості десятків в числі. */
		temp_values[3] = temp_value%10;                /* Виділення кількості одиниць в числі. */
		
		cli();                                         /* Глобальна заборона обробки переривань. */
		
		/* Копіювання виділених цифр в масив для їх подальшого відображення на дисплеї. */
		for(int j = 0; j < (DIGIT_COUNT+1); j++)
		{
			values[j] = temp_values[j];
		}
		
		sei();                                         /* Глобальна активація переривань. */
	}
}

