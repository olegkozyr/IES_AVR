/*
* Програма 4. Використання 16 бітного таймеру для вмикання
* індикаторів дисплею.
*
* Призначення програми: вивід чотирьохзначного десяткового
* числа на дисплей. Числа: 0123, 1234, 2345, ..., 6789.
*
* Обладнання:
* - мікроконтролер ATmega168
* - чотирьох цифровий семисегментний дисплей 7seg-mpx4-ca;
*
* 7seg-mpx4-ca дисплей складається із чотирьом семисегментних
* індикаторів. Індикатори відносяться до типу із загальним анодом,
* тобто всі сегменти (світлодіоди) індикатору з'єднані своїми
* анодами з джерелом живлення. Виводи мікроконтролеру приєднуються
* до катодів світлодіодів. Щоб відобразити на індикаторі
* певну цифру повинна увімкнутись певна комбінація світлодіодів,
* а решта світлодіодів повинна бути вимкнена.
* Для того, щоб світлодіод індикатора із загальним анодом
* увімкнувся на його катоді повинен бути потенціал нижчий за
* потенціал аноду. Тому, для увімкнення певного сегменту
* індикатора на відповідному виході мікроконтролеру повинен
* бути встановлений логічний нуль. Для вимкнення сегменту на
* виході повинна бути логічна одиниця.
*
* Робота з даним типом дисплея має свої особливості. В кожен
* момент часу можна виводити цифру тільки на один індикатор
* дисплея. Тому, в кожен момент часу увімкнутий тільки один
* індикатор, а всі інші вимкнуті.
* Якщо послідовно вмикати кожен індикатор дисплея через досить
* малий проміжок часу, який менший за час реакція ока людини,
* то складається відчуття, що всі сегменти дисплею увімкнуті
* одночасно.
* В симуляторі PROTEUS для дисплею 7seg-mpx4-ca цей час < 10 мс.
*
* Дисплей 7seg-mpx4-ca містить два набори виводів:
* - перший містить вісім виводів, позначені "ABCDEFG DP";
* - другий містить чотири виводи, позначені "1234".
* Перший набір виводів керує сегментами конкретного індикатору.
* "ABCDEFG" виводи керують сегментами (світлодіодами)
* індикатору для відображення цифри.
* "DP" вивід керує світлодіодом, який відображає десяткову точку
* в правому нижньому куті індикатору.
* Другий набір виводів слугує вибору конкретного індикатора
* дисплея.
*
* Виводи порту D приєднані до виводів "ABCDEFG DP" дисплею:
* PD0-"A", PD1-"B", ..., PD6-"G", PD7-"DP".
* Виводи PB0-PB3 приєднані до виводів "1234":
* PB0-"1", PB1-"2", PB2-"3", PB3-"4".
* 
* Кількість тактів таймеру для створення потрібної затримки 
* між перемиканнями індикаторів дисплею:
*
* tdel    = 0,010с.
* fclk_io = 1МГц.
* N       = 8.
* f0      = 1МГц/8           = 125000Гц.
* t0      = 1/125000Гц       = 0,000008с.
* n       = 0,010с/0,000008с = 1250
* 
*/

#define F_CPU            1000000UL                     /* Тактова частота процесору. */
#include <avr/io.h>
#include <avr/interrupt.h>

#define DIGIT_1          (1<<PB0)                      /* Активується 1-й індикатор. */
#define DIGIT_2          (1<<PB1)                      /* Активується 2-й індикатор. */
#define DIGIT_3          (1<<PB2)                      /* Активується 3-й індикатор. */
#define DIGIT_4          (1<<PB3)                      /* Активується 4-й індикатор. */

#define NUMBER_COUNT     06                            /* Кількість перших цифр чотирьох значних 
                                                          чисел - 1: 0123, 1234, 2345, ..., 6789. */

#define DELAY_DISPLAY    19                            /* Кількість циклів повтору виведених цифр 
                                                          на дисплей. */
#define DIGIT_COUNT      03                            /* Кількість індикаторів - 1. */

#define CLEAR_TIMER      TCNT1 = 0x00                  /* Очистка регістру поточного значення 
	                                                      лічильника. */
#define TIMER_COUNT      1250                          /* Кількість тактів лічильника для формуввання
                                                          затримки в 10 мс. */

/* Масив комбінацій значень виводів порту D для відображення цифр від 0 до 9.
   Індекс масиву відповідає цифрі, яку потрібно вивести на індикатор. */
static const uint8_t number_code[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
/* Масив кодів активації індикаторів. */
static const uint8_t digits[] = {DIGIT_1,DIGIT_2,DIGIT_3,DIGIT_4};

/* Лічильники циклів. */
static uint8_t j = 0;                                  /* Поточний індекс масиву number_code. */
static uint8_t i = 0;                                  /* Поточний номер індикатору. */
static uint8_t k = 0;                                  /* Лічильник циклу повтору виведених на 
                                                          дисплей цифр. */

/* Обробник переривань 16-біт таймеру. 
ISR(TIMER1_COMPA_vect)
{
	PORTB = digits[i];                                 /* Активація i-го індикатору. 
	PORTD = number_code[j+i];                          /* Вивід цифри на i-й індикатор. 

	if(i < DIGIT_COUNT)                                /* Доки поточний номер індикатору не досяг 
	                                                      останнього. 
	{
		i++;                                           /* Переходимо на наступний індикатор. 
	}
	else                                               /* Поточний номер досяг номеру 
	                                                      останнього індикатору. 
	{
		i = 0;                                         /* Переходимо до першого індикатору.
		if(k < DELAY_DISPLAY)                          /* Доки поточний цикл повтору виведених
		                                                  на дисплей цифр не досяг останнього значення
														  затримки. 
		{
			k++;                                       /* Переходимо до наступного циклу повтору
			                                              виведення цифр на дисплей. 
		}
		else                                           /* Цикл повтору закінчився. 
		{
			k = 0;
			if(j < NUMBER_COUNT)                       /* Доки поточний номер цифри із масиву
			                                              number_code не досяг останнього значення. 
			{
				j++;                                   /* Переходимо до наступної цифри масиву 
				                                          number_code. 
			}
			else                                       /* Всі цифри із масиву number_code
			                                              виведені на дисплей. 
			{
				j = 0;                                 /* Переходимо до першої цифри. 
			}
		}
	}
}
*/
int main04(void)
{
	/* Ініціалізація вихідних 12 виводів. */
	PORTB = 0x00;
	PORTD = 0x00;
	DDRB = 0x0F;                                       /* Виводи для вибору індикатору. */
	DDRD = 0xFF;                                       /* Виводи для виводу цифр на індикатор. */
	
    /* Налаштування таймеру 1. */
    CLEAR_TIMER;                                                                           
	OCR1A = TIMER_COUNT;                               /* Кількість тактів лічильника. */
	TIMSK1 |= (1<<OCIE1A);                             /* Активація TIMER1_COMPA переривання. */
	sei();                                             /* Глобальна активація переривань. */
	TCCR1A |= 0x00;                                    /* Режим CTC. */
	TCCR1B |= (1<<WGM12)|(1<<CS11);                    /* Вибір внутрішнього джерела тактових 
	                                                      сигналів: fclk_io = F_CPU = 1МГц.
	                                                      Подільник частоти N = 8. 														  
														  Запуск лічильника.*/
	
	while (1)
	{
	}
}

