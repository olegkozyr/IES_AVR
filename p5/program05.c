/*
* Програма 5. Робота з spi інтерфейсом.
*
* Призначення програми: передача із одного
* контролеру байту на інший і виведення його
* на 8-м світлодіодів.
*
* Обладнання:
* - два мікроконтролер ATmega16;
* - 8-м світлодіодів та резисторів.
*
* LCD - рідкокристалічний символьний дисплей. 
* LM016L дисплей складається з модуля відображення та 
* контролера HD44780, який керує дисплеєм. Данні на 
* дисплей виводяться через контролер.
* Існує протокол обміну даними із контролером HD44780,
* який можна знайти в документації до нього.
* Виводи LM016L дисплею:
* - VSS   - "земля";
* - VDD   - живлення;
* - RS    - визначає тип передаваної інформації:
*           0 - команда;
*	        1 - дані;
* - RW    - Напрям передавання інформації:
*           0 - запис в контролер дисплею;
*	        1 - зчитування із контролеру;
* - E     - при зміні значення на даному виводі
*           від 1 до 0 починається процес
*		    запису/зчитування інформації;
* - D0-D7 - паралельна 8-біт шина обміну
*           даними з дисплеєм;
* За один цикл на дисплей можна передати один байт.
* Існує два режими передавання байту в контролер 
* дисплею:
* 1) передача байта за один цикл; при цьому 
*    використовуються всі вісім виводів D0-D7;
* 2) передача байта за два цикли; при цьому 
*    використовуються тільки чотири виводи D4-D7; 
*    інформація передається повільніше, але 
*    використовується менше виводів;
*    в даному режимі байт передається половинами
*    спочатку старші 4-ри біти потім молодші;
* Вибір режиму проводиться при ініціалізації дисплею.
*
* Виводи контролера ATmega168 при 4-біт режимі роботи LCD,
* приєднані до дисплею:
* PD2 - RS
* PD3 - E
* PD4 - D4
* PD5 - D5
* PD6 - D6
* PD7 - D7
*
* Виводи дисплею:
* VSS -	приєднаний до "землі" ;
* VDD - до живлення;
* RW - до нульового потенціалу - запис в контролер дисплею.
*
* Джерело опорного живлення приєднано до виводу AVCC.
* Вхідний аналоговий канал АЦП: ADC6. До цього каналу приєднаний
* середній вивід потенціометра.
* АЦП - 10 розрядний, тому для зберігання 10 розрядів
* двійкового коду потрібна 16 розрядна змінна.
* Роздільна здатність 10 бітного АЦП:
* розмах напруги: 0...5 В;
* dV = 5/1024 = 0,0048828125 В.
*
* Розрахунок кількості тактів таймеру для визначення 
* часу між перериваннями:
*
* Час між перериваннями таймера            t_inter.
* Тактова частота периферійних модулів     fclk_io.
* Подільник частоти                        N.
* Тактова частота таймера                  f0 = fclk_io/N.
* Часова роздільна здатність таймера       t0 = 1/f0.
* Кількість тактів таймеру для досягнення 
* t_inter:                                 m  = t_inter/t0.
*
* t_inter = 0,1с.
* fclk_io = 1МГц.
* N       = 64.
* f0      = 1МГц/64        = 15625Гц.
* t0      = 1/15625Гц      = 0,000064с.
* m       = 0,1с/0,000064с = 1562
*
*/

#include "lcd.h" 
#include <avr/interrupt.h>

#define CLEAR_TIMER        TCNT1 = 0x00                /* Очистка регістру поточного значення 
	                                                      лічильника. */
#define TIMER1_COMPA_COUNT OCR1A = 1562                /* Кількість тактів таймеру. */
#define DIGIT_COUNT        4                           /* Кількість цифр в числі, яке виводиться 
                                                          на LCD. */
#define STRING_COUNT       DIGIT_COUNT+2               /* Довжина строки, яка виводиться на дисплей.
                                                          На двійку більше тому, що виводиться 
														  десяткова точка після розряду одиниць 
														  та строка закінчується символом '\0'. */
#define NUMBER_CODE        0x30                        /* Код ноля в таблиці ASCII. */

uint8_t string[STRING_COUNT];                          /* Масив для збереження цифр числа. */

/* Ініціалізація виводів мікроконтролеру ATmega168. */
void port_init(void)
{
	PORTD = 0x00;
	DDRD = 0xFF;
}

/* Ініціалізація таймера 1. */
void timer1_init(void)
{
	CLEAR_TIMER;                                      
	TCCR1A = 0x00;                                     
	TIMER1_COMPA_COUNT;                                /* Кількість тактів лічильника. */
	TIMSK1 = (1<<OCIE1A);                              /* Активація TIMER1_COMPA переривання. */
	sei();                                             /* Глобальна активація переривань. */
	TCCR1B = (1<<WGM12)|(1<<CS11)|(1<<CS10);           /* Вибір внутрішнього джерела тактових 
	                                                      сигналів: fclk_io = F_CPU = 1МГц.
	                                                      Подільник частоти N = 64. 
														  Режим CTC.
														  Запуск лічильника.*/
}

/* Ініціалізація АЦП. */
void adc_init(void)
{
	/* Ініціалізація АЦП */
	ADMUX |= (1<<REFS0)|(1<<MUX2)|(1<<MUX1);           /* Опорна напруга на AVCC, ADC6 вхід. */
	ADCSRA |= (1<<ADPS1)|(1<<ADPS0);                   /* Подільник тактової частоти, N=8. */
	ADCSRA |= (1<<ADEN);                               /* Активація АЦП. */
}

/* Перетворення числа в строку з кодуванням ASCII. */
uint8_t* num_to_string(uint16_t number)
{
	string[0] = number/1000+NUMBER_CODE;
	number %= 1000;
	string[1] = '.';
    string[2] = number/100+NUMBER_CODE;
	number %= 100;
	string[3] = number/10+NUMBER_CODE;
	number %= 10;
    string[4] = number/1+NUMBER_CODE;	 
	string[5] = '\0';
	
	return string;
}

/* Обробник переривань 16-біт таймеру 1. */
ISR(TIMER1_COMPA_vect)
{
	set_position(0, 1); 
	print_lcd(string);
}

int main(void)
{
	port_init();
	lcd_init();
	set_position(0, 0);
	print_lcd("Input voltage:");
	adc_init();
	timer1_init();
	
	uint16_t temp_value = 0;                           /* Тимчасова змінна для зберігання значення
	                                                      АЦП та результату перетворення код->число. */
	float fvalue = 0.0f;                               /* Дійсне значення напруги на вході АЦП. */
	
    while (1)
    {
		_delay_ms(200);                                /* Затримка між перетвореннями АЦП. */ 
		
		/* Отримання коду АЦП. */
		ADCSRA |= (1<<ADSC);                           /* Запуск перетворення аналогового сигналу в код. */
		while((ADCSRA & (1<<ADSC))>0);                 /* Чекаємо завершення перетворення. */
		temp_value = ADC;                              /* Результат перетворення зберігається в 
	                                                      16 розрядному регістрі ADC. */
		
		fvalue = 5.0f*(temp_value)/1024.0f;            /* Перетворення коду АЦП в значення напруги. */
		temp_value = fvalue*1000.0f;                   /* Виділення старших 4-х розрядів. */
		
		cli();                                         /* Глобальна заборона обробки переривань. */
		num_to_string(temp_value);
		sei();
    }
}

