/*
* Програма 5. Робота з SPI інтерфейсом в режимі Slave.
*
* Призначення програми: зчитування байту із порту D та 
* передача його по інтерфейсу SPI на Master контролер 
* для відображення.
*
* Даний вихідний код завантажується в Slave контролер.
*
* Обладнання:
* - мікроконтролер ATmega168;
* - набір із восьми логічних ключів LOGICTOGGLE.
*
* З'єднання виводів мікроконтролеру:
* Виводи приймання інформації:
* - виводи PD0-PD7 порту D - приєднані до восьми 
*   логічних ключів;
* Передавання інформації по шині SPI:
*   Slave     Master    
* - MOSI   :  MOSI;
* - MISO   :  MISO;
* - SCK    :  SCK ;
* - SS     :  SS  ;
*
* В даному коді передача байту від Slave до Master контролеру
* відбувається в два етапи:
* 1) Master надсилає в Slave байт з будь-яким значенням, як
* сигналізація того щоб Slave завантажив у свій регістр даних
* байт стану логічних ключів LOGICTOGGLE.
* 2) Master надсилає в Slave другий раз байт з будь-яким значенням,
* при цьому паралельно зчитує із Slave інформативний байт.
* 
* Передавання даних від Slave до Master контролеру відбувається 
* наступним чином.
* Slave контролер не може ініціалізувати передачу байту даних.
* Він може тільки чекати доки Master контролер надішле байт.
* Під час передачі байту від Master до Slave контролеру по виводу MOSI,
* паралельно передається байт від Slave до Master контролеру
* по виводу MISO.
* Тому, в циклі while функції main постійно викликається
* функція spi_transmit_byte. 
* Дана функція складається із 4-х операцій:
* 1) WAIT_TRANSMISSION_END - виконується доки не установиться
* прапорець SPIF в регістрі SPSR - показник того, що Master
* хоче отримати байт від Slave (при цьому Master в Slave
* передав порожній байт із нулів).
* 2) UPLOAD_BYTE(byte) - запис байту в регістр даних SPDR
* для передачі в Master при наступному сеансі обміну даними.
* Внаслідок виконання першої та другої операцій очистився
* прапорець SPIF в регістрі SPSR.
* 3) WAIT_TRANSMISSION_END - виконується доки знов не установиться
* прапорець SPIF в регістрі SPSR - показник того, що Master
* зчитав байт у Slave (при цьому Master в Slave
* передав порожній байт із нулів).
* 4) UPLOAD_BYTE(byte) - запис байту в регістр даних SPDR
* для того, щоб очистився прапорець SPIF в регістрі SPSR.
*
* Прапорець SPIF в регістрі SPSR забирається:
* 1) зчитується регістр SPSR;
* 2) зчитується/записується значення регістра даних SPDR.
*
*/

#define F_CPU              1000000UL                   /* Тактова частота процесора. */
#include <avr/io.h>
#include <util/delay.h>

#define MISO                   PB4                     /* Вивід для передачі байту інформації до
                                                          Master контролеру. */
														  
#define LOGIC_KEY_STATES       PIND                    /* Стан логічних ключів на вході порту D. */

#define TRANSMISSION_NOT_ENDED (!(SPSR & (1<<SPIF)))   /* Перевірка відсутності прапорця SPIF 
                                                          в регістрі SPSR. */
														  
#define WAIT_TRANSMISSION_END  while(TRANSMISSION_NOT_ENDED) /* Чекаємо закінчення передачі. */

#define UPLOAD_BYTE(byte)      SPDR = byte             /* Запис байту в регістр даних. */

/* Ініціалізація виводів мікроконтролеру ATmega168. */
void port_init(void)
{
    /* Входи для зчитування стану
	   восьми логічних ключів LOGICTOGGLE. */
	DDRD = 0x00;
	
	/* Ініціалізація SPI інтерфейсу. */
    DDRB = (1<<MISO);                                  /* Встановлення виводів SPI шини:
                                                          - MOSI SCK SS - на вхід;
														  - MISO - на вихід. */
    SPCR = (1<<SPE);                                   /* SPE - Активація SPI шини. */	
	/* Очищення SPIF прапорця за рахунок зчитування 
	   SPSR та SPDR регістрів. */
	volatile uint8_t tempByte;
	tempByte = SPSR;
	tempByte = SPDR;
}

/* Передача байту по шині SPI. */
void spi_transmit_byte(uint8_t byte)
{
	WAIT_TRANSMISSION_END;
    UPLOAD_BYTE(byte); 
	WAIT_TRANSMISSION_END;  
    UPLOAD_BYTE(byte);	
}

int main(void)
{
	port_init();
	
    while (1)
    {
        spi_transmit_byte(LOGIC_KEY_STATES);
    }
}

