/*
* Програма 5. Робота з SPI інтерфейсом в режимі Master.
*
* Призначення програми: зчитування байту із порту D та 
* передача його по інтерфейсу SPI на інший контролер 
* для відображення. 
*
* Даний вихідний код завантажується в керуючий контролер.
*
* Обладнання:
* - мікроконтролер ATmega168;
* - набір із восьми логічних ключів LOGICTOGGLE.
*
* З'єднання виводів мікроконтролеру:
* Виводи приймання інформації:
* - виводи PD0-PD7 порту D - приєднані до восьми 
*   логічних ключів;
* Передавання інформації по шині SPI:
*   Master    Slave
* - MOSI   :  MOSI;
* - MISO   :  MISO;
* - SCK    :  SCK ;
* - SS     :  SS  ;
*
*/

#define F_CPU              1000000UL                   /* Тактова частота процесора. */
#include <avr/io.h>
#include <util/delay.h>

#define SS                 PB2                         /* Вивід дозволяє/забороняє передавання даних
                                                          по шині:
														  - 1 - передавання даних заборонене;
														  - 0 - дозволяє передавання даних. */
#define MOSI               PB3                         /* Вивід для передачі байту інформації до
                                                          Slave контролеру. */
#define SCK                PB5                         /* Вивід для передачі синхро-імпульсів. */

#define LOGIC_KEY_STATES   PIND                        /* Стан логічних ключів на вході порту D. */

/* Ініціалізація виводів мікроконтролеру ATmega168. */
void port_init(void)
{
    /* Входи для зчитування байту інформації. */
	DDRD = 0x00;
	
	/* Ініціалізація SPI інтерфейсу. */
    DDRB = (1<<MOSI)|(1<<SCK)|(1<<SS);                 /* Встановлення виводів SPI шини:
                                                          - MOSI SCK SS - на вихід;
														  - MISO - на вхід. */
	PORTB = 0x00;                                      /* На вивід SS подається 0. */
    SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);               /* SPE - Активація SPI шини;
                                                          MSTR - контролер пряцює в режимі Master;
                                                          SPR0 - подільник частоти - 16 */
	/* Очищення SPIF прапорця за рахунок зчитування 
	   SPSR та SPDR регістрів. */
	volatile uint8_t tempByte;
	tempByte = SPSR;
	tempByte = SPDR;
}

/* Передача байту по шині SPI. */
void spi_transmit_byte(uint8_t byte)
{
    SPDR = byte;                                       /* Початок передачі байту. */
	while(!(SPSR & (1<<SPIF)));                        /* Чекаємо закінчення передачі. */
}

int main(void)
{
	port_init();
	
    while (1)
    {
		spi_transmit_byte(LOGIC_KEY_STATES);
		_delay_ms(100);
    }
}

